package main

import (
	"database/sql"
	"fmt"
	"net/http"
	"strings"

	"github.com/gin-gonic/gin"
	_ "github.com/lib/pq"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
	"github.com/sashabaranov/go-openai"
)

func main() {

	zerolog.TimeFieldFormat = zerolog.TimeFormatUnix

	host := getEnvWithoutDefaults("HOST")
	user := getEnvWithoutDefaults("USER")
	password := getEnvWithoutDefaults("PASSWORD")
	port := getEnvWithoutDefaults("PORT")
	dbname := getEnvWithoutDefaults("DATABASE")

	client := openai.NewClient(getEnvWithoutDefaults("OPENAI_API_KEY"))

	log.Info().Msg("Starting the server...")

	// Set up PostgreSQL connection
	url := fmt.Sprintf("postgres://%s:%s@%s:%s/%s?sslmode=disable", strings.TrimSpace(user), strings.TrimSpace(password), strings.TrimSpace(host), port, strings.TrimSpace(dbname))

	log.Debug().Msg("Connecting to the database with URL: " + url)
	db, err := sql.Open("postgres", url)
	if err != nil {
		log.Fatal().Err(err).Msg("failed to connect to the database")
	}
	defer db.Close()

	router := gin.Default()

	// Endpoint to get patch recommendation
	router.POST("/recommend", func(c *gin.Context) {
		var query struct {
			Decision string `json:"decision" binding:"required"`
		}
		if err := c.ShouldBindJSON(&query); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
			return
		}

		// Simulate embedding retrieval based on decision description
		embedding, err := getEmbedding(query.Decision, client)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
			return
		}

		similarCves, err := retrieveSimilarCVEDescriptions(db, embedding)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
			return
		}

		recommendation, err := generateRecommendation(client, query.Decision, similarCves)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
			return
		}

		c.JSON(http.StatusOK, gin.H{"recommendation": recommendation})
	})

	router.GET("/healthz", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{"status": "ok"})
	})

	router.GET("/ready", func(c *gin.Context) {
		dbErr := db.Ping()
		if dbErr != nil {
			c.JSON(http.StatusServiceUnavailable, gin.H{"status": "error"})
			log.Error().Err(dbErr).Msg("Database is not ready")
			return
		}
		c.JSON(http.StatusOK, gin.H{"status": "ok"})
	})

	router.Run(":8080")
}
